# -*- coding: utf-8 -*-
"""Rooney.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P-k9atjNY8MIdTyM2OONWIrZNOt5fmqA
"""

import pandas as pd
import numpy as np
!pip install ortools
from ortools.linear_solver import pywraplp
Comus='/content/cosmus.xlsx'
data = pd.read_csv('/content/tabela_necessidades_dieteticas.csv')

data

Mulher = data[data['Sexo'] == 'Mulher']
x = Mulher['Peso (kg)']
x = np.array(x).reshape(-1,1) # colocar numpy e como coluna
x

y = Mulher['Proteínas (g/dia)']
y = np.array(y).reshape(-1,1) # colocar numpy e como coluna
y

valor = 64
input = np.array([[valor]])

from sklearn.linear_model import LinearRegression

model = LinearRegression()

model.fit(x,y)

model.predict(input)

# Passar uma amostragem de pontos para o preditor criado
xx = np.linspace(40,70, 100)
yhat = model.predict(xx.reshape(-1,1))

import matplotlib.pyplot as plt

plt.plot(x,y, 'ro')
plt.plot(xx,yhat,'k--')

from sklearn.linear_model import LinearRegression

# Definir as variáveis de entrada e as variáveis-alvo
input_features = ["Peso (kg)"]
target_features = ["Proteínas (g/dia)", "Carboidratos (g/dia)", "Gorduras (g/dia)", "Vitamina A (mcg/dia)", "Vitamina C (mg/dia)", "Cálcio (mg/dia)", "Ferro (mg/dia)"]

# Entrada: Sexo e peso


sexo = str(input('Coloque seu sexo: '))
peso = str(input('Coloque seu peso: '))

# Filtrar dados por sexo
filtered_data = data[data['Sexo'] == sexo]

# Treinar o modelo de regressão linear para cada variável-alvo
models = {}
for target in target_features:
    model = LinearRegression()
    model.fit(filtered_data[input_features], filtered_data[target], sample_weight=None)
    models[target] = model

# Prever os valores intermediários para o peso dado
predictions = {}
for target, model in models.items():
    prediction = model.predict(pd.DataFrame(data=[[peso]], columns=input_features))
    predictions[target] = prediction[0]
lista = []
# Imprimir os resultados
print(f"Valores interpolados para {sexo} com {peso} kg:")
for target, value in predictions.items():
    print(f"{target}: {value:.2f}")
    lista.append(value)

df = pd.read_excel('/content/za.xlsx')
df = df.loc[:, ~df.columns.str.contains('^Unnamed')]
df.fillna(0, inplace=True)

df

proc = lista[0]/5
carc = lista[1]/5
gorc = lista[2]/5
vac = lista[3]/5
vcc = lista [4]/5
calc = lista[5]/5
ferc = lista[6]/5
cafc = 0

proa = lista[0]*3/5
cara = lista[1]*3/5
gora = lista[2]*3/5
vaa = lista[3]*3/5
vca = lista [4]*3/5
cala = lista[5]*3/5
fera = lista[6]*3/5
cafa = 1

print(proa)

alimentos_df = pd.read_excel('/content/za.xlsx')
alimentos_df

from ortools.linear_solver import pywraplp
import pandas as pd

# Carregar os dados dos alimentos do arquivo Excel
alimentos_df = pd.read_excel('/content/za.xlsx')



# Definir o solver
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df.iloc[i]['d']) for i in range(len(alimentos_df))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= carc)
solver.Add(sum(alimentos_df.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= proc)
solver.Add(sum(alimentos_df.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= gorc)
solver.Add(sum(alimentos_df.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vac)
solver.Add(sum(alimentos_df.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vcc)
solver.Add(sum(alimentos_df.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= calc)
solver.Add(sum(alimentos_df.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= ferc)
solver.Add(sum(alimentos_df.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) <= cafc)




# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Verificar se a solução foi encontrada
if status == pywraplp.Solver.OPTIMAL:
    print('Dieta otimizada encontrada:')
    for i in range(len(alimentos_df)):
        if quantidades_alimentos[i].solution_value() > 0:
            print(f"{alimentos_df.iloc[i]['d']}: {quantidades_alimentos[i].solution_value()} unidades")
else:
    print('Não foi possível encontrar uma solução ótima para a dieta.')

# Definir o solver
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df.iloc[i]['d']) for i in range(len(alimentos_df))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= carc)
solver.Add(sum(alimentos_df.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= proc)
solver.Add(sum(alimentos_df.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= gorc)
solver.Add(sum(alimentos_df.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vac)
solver.Add(sum(alimentos_df.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vcc)
solver.Add(sum(alimentos_df.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= calc)
solver.Add(sum(alimentos_df.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= ferc)
solver.Add(sum(alimentos_df.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= cafc)




# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Excluir os alimentos usados na dieta otimizada
alimentos_usados = []
for i in range(len(alimentos_df)):
    if quantidades_alimentos[i].solution_value() > 0:
        alimentos_usados.append(alimentos_df.iloc[i]['d'])

# Filtrar o DataFrame de alimentos para excluir os alimentos usados
alimentos_df_filtrado = alimentos_df[~alimentos_df['d'].isin(alimentos_usados)]
alimentos_df_filtrado = alimentos_df_filtrado[alimentos_df_filtrado['caf'] != 0]

# Atualizar o solver com o novo DataFrame de alimentos
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df_filtrado.iloc[i]['d']) for i in range(len(alimentos_df_filtrado))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df_filtrado.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cara)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= proa)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= gora)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= vaa)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= vca)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cala)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= fera)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cafc)

# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Verificar se a solução foi encontrada
if status == pywraplp.Solver.OPTIMAL:
    print('Nova dieta otimizada encontrada:')
    for i in range(len(alimentos_df_filtrado)):
        if quantidades_alimentos[i].solution_value() > 0:
            print(f"{alimentos_df_filtrado.iloc[i]['d']}: {quantidades_alimentos[i].solution_value()} unidades")
else:
    print('Não foi possível encontrar uma solução ótima para a nova dieta.')

# Definir o solver
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df.iloc[i]['d']) for i in range(len(alimentos_df))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= carc)
solver.Add(sum(alimentos_df.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= proc)
solver.Add(sum(alimentos_df.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= gorc)
solver.Add(sum(alimentos_df.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vac)
solver.Add(sum(alimentos_df.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= vcc)
solver.Add(sum(alimentos_df.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= calc)
solver.Add(sum(alimentos_df.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= ferc)
solver.Add(sum(alimentos_df.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df))) >= cafc)




# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Excluir os alimentos usados na dieta otimizada
alimentos_usados = []
for i in range(len(alimentos_df)):
    if quantidades_alimentos[i].solution_value() > 0:
        alimentos_usados.append(alimentos_df.iloc[i]['d'])

# Filtrar o DataFrame de alimentos para excluir os alimentos usados
alimentos_df_filtrado = alimentos_df[~alimentos_df['d'].isin(alimentos_usados)]
alimentos_df_filtrado = alimentos_df_filtrado[alimentos_df_filtrado['caf'] != 0]

# Atualizar o solver com o novo DataFrame de alimentos
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df_filtrado.iloc[i]['d']) for i in range(len(alimentos_df_filtrado))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df_filtrado.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cara)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= proa)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= gora)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= vaa)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= vca)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cala)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= fera)
solver.Add(sum(alimentos_df_filtrado.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado))) >= cafc)

# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Excluir os alimentos usados na dieta otimizada
alimentos_usados2 = []
for i in range(len(alimentos_df_filtrado)):
    if quantidades_alimentos[i].solution_value() > 0:
        alimentos_usados2.append(alimentos_df_filtrado.iloc[i]['d'])

# Filtrar o DataFrame de alimentos para excluir os alimentos usados
alimentos_df_filtrado2 = alimentos_df_filtrado[~alimentos_df_filtrado['d'].isin(alimentos_usados2)]

# Atualizar o solver com o novo DataFrame de alimentos
solver = pywraplp.Solver.CreateSolver('GLOP')

# Variáveis de decisão para a quantidade de cada alimento
quantidades_alimentos = [solver.IntVar(0, solver.infinity(), alimentos_df_filtrado2.iloc[i]['d']) for i in range(len(alimentos_df_filtrado2))]

# Restrições para garantir que os requisitos nutricionais sejam atendidos
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['c'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= carc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['p'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= proc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['g'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= gorc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['va'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= vac)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['vc'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= vcc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['cal'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= calc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['f'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= ferc)
solver.Add(sum(alimentos_df_filtrado2.iloc[i]['caf'] * quantidades_alimentos[i] for i in range(len(alimentos_df_filtrado2))) >= cafc)

# Função objetivo para minimizar o número total de alimentos
objective = solver.Objective()
for var in quantidades_alimentos:
    objective.SetCoefficient(var, 1)
objective.SetMinimization()

# Resolver o problema
status = solver.Solve()

# Verificar se a solução foi encontrada
if status == pywraplp.Solver.OPTIMAL:
    print('Nova dieta otimizada encontrada:')
    for i in range(len(alimentos_df_filtrado2)):
        if quantidades_alimentos[i].solution_value() > 0:
            print(f"{alimentos_df_filtrado2.iloc[i]['d']}: {quantidades_alimentos[i].solution_value()} unidades")
else:
    print('Não foi possível encontrar uma solução ótima para a nova dieta.')